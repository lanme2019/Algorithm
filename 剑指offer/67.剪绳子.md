#  题目描述

给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

#  思路解析

两种思路  贪心算法和动态规划

> 动态规划(DP) ： 先找局部最优，推导出整体最优，自上向下分析，自下向上求解

DP[i] = max(DP[j] * DP[i - 1]);

> 贪心算法 : 先通过举例找出规律

 * 先举几个例子，可以看出规律来。
 * 4 ： 2*2
 * 5 ： 2*3
 * 6 ： 3*3
 * 7 ： 2*2*3 或者4*3
 * 8 ： 2*3*3
 * 9 ： 3*3*3
 * 10：2*2*3*3 或者4*3*3
 * 11：2*3*3*3
 * 12：3*3*3*3
 * 13：2*2*3*3*3 或者4*3*3*3
 
 可以看出从`5`开始,每一个数的最优解都可以分解成若干个`2`和`3`的乘积
 
 那么问题就转化成分解成几个2和3的问题  3*3 > 2*2*2  `3`的权重大于`2`  将数值对`3`取余会出现三种情况
 
 - 1.余数取`0`  最大值由`n`个`3`组成
 - 2.余数取`1`     
 - 3.余数取`2`  


```java
// 动态规划DP
public class Solution {
    public int cutRope(int target) {
        //先返回特殊情况
        if (target == 2) {
            return 1;
        }
        if (target == 3) {
            return 2;
        }
        int[] dp = new int[target + 1];
        //dp数组储存每一个值得最优解
        //dp[i] = max (dp[j] * dp[i - j]);
        // 在求 dp[i] 时  如果我们知道 dp[i] 之前的每一个值 就可以求出 dp[i] 的最优解
        dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3;
        for (int i = 4; i <= target; i++) {
            // max 储存每轮最优解
            int max = 0;
            for (int j = 1; j <= i/2; j++) {
                max = Math.max(max,dp[j] * dp[i - j]);
                dp[i] = max;
            }
        }
        return dp[target];
    } 
}



// 贪心算法
```

